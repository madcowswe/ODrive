import sys
import serial
import time
import threading
import json
import random
import Queue
from fractions import gcd
from WebSocketServer import WebSocket, SimpleWebSocketServer

from generated.ODriveAutoGenerated import ODriveAutoGenerated
from generated.MappingAutoGenerated import variable_map
from generated.ErrorAutoGenerated import error_map
from ControlMode import ControlMode
from Motor import Motor

DEBUG = False

websocket_clients = []
websocketServer = None
odrive = None


class Monitoring():

    def __init__(self, datatype, idnumber, frequency):
        self.datatype = datatype
        self.idnumber = idnumber
        self.slot = 999  # slot gets auto assigned by _reorder_monitoring
        self.frequency = frequency


class WebsocketServer():

    def __init__(self, host, port):
        self.host = host
        self.port = port
        self.server = None
        
        self.chartdataqueue = Queue.Queue(100)
        
        t = threading.Thread(target=self.thread)
        t.daemon = True
        t.start()
        
        t = threading.Thread(target=self.chartSendThread)
        t.daemon = True
        t.start()

        self.running = True
        
        
    def thread(self):
        print "Starting ODrive websocket on %s:%s" % (self.host, self.port)
        self.server = SimpleWebSocketServer(self.host, self.port, self.MsgServer)
        self.server.serveforever()
        self.running = False

    def chartSendThread(self):
        while True:
            chartdata = self.chartdataqueue.get()
            self.sendToClients(json.dumps({"chart": chartdata}))
    
    def sendToClients(self, msg):
        for c in websocket_clients:
            c.sendMessage(msg)

    def send_chartdata(self, chartdata):
        try:
            self.chartdataqueue.put(chartdata,False)#
        except:
            None

    class MsgServer(WebSocket):

        def handleMessage(self):
            # TODO : don't rely on global odrive variable..
            try:
                data = json.loads(self.data.decode("utf-8"))
                results = []
                if data.keys()[0] == "getAll":
                    for key in variable_map.keys():
                        datatype, idnumber = variable_map[key].datatype, variable_map[key].idnumber
                        value = odrive._get(datatype, idnumber)
                        results.append([datatype, idnumber, value])
                    self.sendMessage(json.dumps({"values": results}))

                if data.keys()[0] == "get":
                    datatype, idnumber = data["get"]["type"], data["get"]["nr"]
                    value = odrive._get(datatype, idnumber)
                    results.append([datatype, idnumber, value])
                    self.sendMessage(json.dumps({"values": results}))

                if data.keys()[0] == "set":
                    odrive._set(data["set"]["type"], data["set"]["nr"], data["set"]["value"])

                if data.keys()[0] == "monitor":
                    odrive._monitor(data["monitor"]["type"], data["monitor"]["nr"], data["monitor"]["frequency"])

            except Exception, e:
                print e

        def handleConnected(self):
            print((self.address, 'connected'))
            self.sendMessage(json.dumps({"mappings": [{"name": variable_map[k].name, "type":variable_map[k].datatype, "nr":variable_map[k].idnumber, "access":variable_map[k].access, "min":variable_map[k].min, "max":variable_map[k].max} for k in variable_map.keys()]}))
            websocket_clients.append(self)

        def handleClose(self):
            print((self.address, 'closed'))
            websocket_clients.remove(self)


class ODrive(ODriveAutoGenerated):

    def __init__(self, tty):
        if tty == "none":
            self._serial = None
        else:
            self._serial = serial.Serial(tty)
        self.motors = [
            Motor(0, self),
            Motor(1, self),
        ]

        # Monitoring stuff
        self.active_monitorings = []
        self.base_delay = 1  # in seconds
        # how many array values do we have to read at what cycle of the
        # monitoring loop to match the user given monitoring frequency
        self.multipliers_highest_indexes = {}
        # these external functions are called by the monitoring thread on new
        # data.
        self.monitoring_callbacks = []
        self.monitoring_lock = threading.Lock()
        t = threading.Thread(target=self._monitoring_thread)
        t.daemon = True
        t.start()

    def _monitoring_thread(self):
        cnt = 0  # loop step count
        while True:
            self.monitoring_lock.acquire()
            starttime = time.time()
            for x in sorted(self.multipliers_highest_indexes.keys(), reverse=True):
                if cnt % x == 0:
                    index = self.multipliers_highest_indexes[x]
                    self._ttysend("o %s" % (index + 1))
                    resultstr = self._ttyread()

                    if self._serial == None:
                        resultarray = [random.randint(0, 100) for i in range(0, index + 1)]
                    else:
                        resultarray = resultstr.split("\t")
                    results = []
                    for i in range(0, index + 1):
                        results.append((self.active_monitorings[i].datatype, self.active_monitorings[i].idnumber, float(resultarray[i])))
                    for callback in self.monitoring_callbacks:
                        callback(results)
                    break
            self.monitoring_lock.release()
            cnt += 1
            diff = time.time() - starttime
            sleeptime = self.base_delay - diff
            if sleeptime < 0.00001:
                sleeptime = 0.00001
                print "warning,can't reach base frequency"
            time.sleep(sleeptime)

    # order monitoring so most frequently used values are on start of
    # monitoring slots
    def _reorder_monitoring(self):
        if len(self.active_monitorings) == 0:
            self.base_delay = 1
            self.multipliers_highest_indexes = {}
            return

        self.active_monitorings.sort(key=lambda x: x.frequency, reverse=True)

        base_delay = reduce(gcd, [int((1.0 / m.frequency) * 10000) for m in self.active_monitorings]) # in 1/10  ms, so base base freq is max 10khz
        base_frequency = 1.0 / (base_delay) * 10000.0
        self.base_delay = base_delay / 10000.0
        new_multipliers_highest_indexes = {}
        for index in range(0, len(self.active_monitorings)):
            mon = self.active_monitorings[index]
            if mon.slot != index:
                mon.slot = index
                self._ttysend("m %s %s %s" % (mon.datatype, mon.idnumber, mon.slot))

            multiplier = int(base_frequency / self.active_monitorings[index].frequency)
            try:
                if new_multipliers_highest_indexes[multiplier] < index:
                    new_multipliers_highest_indexes[multiplier] = index
            except:
                new_multipliers_highest_indexes[multiplier] = index

        self.multipliers_highest_indexes = new_multipliers_highest_indexes

    # these functions are used by the auto generated code
    def _get(self, datatype, idnumber):
        self._ttysend("g %s %s" % (datatype, idnumber))
        value = self._ttyread()
        return self._convert_get(datatype, value)

    def _set(self, datatype, idnumber, value):
        self._ttysend("s %s %s %s" % (datatype, idnumber, self._convert_set(datatype, value)))

    def _monitor(self, datatype, idnumber, frequency):
        self.monitoring_lock.acquire()
        self.active_monitorings = [ m for m in self.active_monitorings if m.datatype != datatype or m.idnumber != idnumber]
        if frequency > 0:
            m = Monitoring(datatype, idnumber, frequency)
            self.active_monitorings.append(m)
        self._reorder_monitoring()
        self.monitoring_lock.release()
        
    def _convert_get(self, datatype, value):
        if datatype == 0:
            return float(value)
        if datatype == 1:
            return int(value)
        if datatype == 2:
            if int(value) == 1:
                return True
            return False

    def _convert_set(self, datatype, value):
        if datatype == 0:
            return float(value)
        if datatype == 1:
            return int(value)
        if datatype == 2:
            if value == True:
                return 1
            return 0

    # raw tty functions, lowest level

    def _ttysend(self, data):
        if DEBUG:
            print "sending '%s'" % data
        if self._serial != None:
            self._serial.write(data)
        else:
            print "Serial dummy: %s" % data

    def _ttyread(self):
        if self._serial != None:
            result = self._serial.readline()
        else:
            result = 1
        if DEBUG:
            print "received '%s'" % result
        return result


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print "Usage: "
        print "Odrive.py tty <ip:port>"
        print ""
        print "tty     : tty device, required"
        print "ip:port : optional, defaults to 127.0.0.1:12342"
        print ""
        exit(1)

    TTY = sys.argv[1]
    HOST = "127.0.0.1"
    PORT = 12342

    try:
        HOST = sys.argv[2].split(":")[0]
        PORT = int(sys.argv[2].split(":")[1])
    except:
        pass
        
    websocketServer = WebsocketServer(HOST, PORT)

    odrive = ODrive(TTY)
    odrive.monitoring_callbacks.append(websocketServer.send_chartdata)

    from IPython import embed
    embed()
